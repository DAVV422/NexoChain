{
  "language": "Solidity",
  "sources": {
    "contracts/JobScrow.sol": {
      "content": "\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title JobEscrow\r\n * @dev Este contrato gestiona un depósito en garantía (escrow) para trabajos entre\r\n * un empleador y un freelancer, con un árbitro y una comisión para la plataforma.\r\n */\r\ncontract JobEscrow {\r\n    // PASO 1: Se añade el estado 'Open' para las vacantes sin freelancer asignado.\r\n    enum JobState { Open, InProgress, Completed, Disputed, Resolved }\r\n\r\n    // Estructura para almacenar los detalles de cada trabajo.\r\n    struct Job {\r\n        address employer;      // La dirección del empleador.\r\n        address freelancer;    // La dirección del freelancer (es 0x0 hasta que se contrata a alguien).\r\n        uint256 amount;        // El monto en garantía (bruto al inicio, neto después de la comisión).\r\n        JobState state;        // El estado actual del trabajo.\r\n        string description;    // Descripción de la vacante.\r\n        string[] skills;       // Habilidades requeridas para la vacante.\r\n        string imageURI;       // URI de la imagen para la vacante.\r\n    }\r\n\r\n    // Mapeo de un ID de trabajo a su estructura de datos.\r\n    mapping(uint256 => Job) public jobs;\r\n    uint256 public nextJobId = 1;\r\n\r\n    // --- ROLES DEL CONTRATO ---\r\n    address public immutable arbiter; \r\n    address public immutable platformOwner;\r\n    uint8 public immutable commissionPercentage;\r\n\r\n\r\n    // --- EVENTOS (Actualizados para el nuevo flujo) ---\r\n    event VacancyCreated(uint256 indexed jobId, address indexed employer, uint256 amount, string description, string[] skills, string imageURI);\r\n    event FreelancerHired(uint256 indexed jobId, address indexed freelancer, uint256 netAmount, uint256 commission);\r\n    event FundsReleased(uint256 indexed jobId, address indexed freelancer, uint256 amount);\r\n    event DisputeRaised(uint256 indexed jobId, address indexed raisedBy);\r\n    event DisputeResolved(uint256 indexed jobId, uint256 freelancerAmount, uint256 employerAmount);\r\n\r\n    /**\r\n     * @dev El constructor no cambia. Define los roles al desplegar el contrato.\r\n     */\r\n    constructor(address _arbiter, address _platformOwner, uint8 _commissionPercentage) {\r\n        require(_arbiter != address(0), \"La direccion del arbitro no puede ser la direccion cero.\");\r\n        require(_platformOwner != address(0), \"La direccion del dueno de la plataforma no puede ser la direccion cero.\");\r\n        require(_commissionPercentage < 100, \"La comision debe ser menor al 100%.\");\r\n        \r\n        arbiter = _arbiter;\r\n        platformOwner = _platformOwner;\r\n        commissionPercentage = _commissionPercentage;\r\n    }\r\n\r\n    /**\r\n     * @dev PASO 2: Nueva función para crear una vacante (antes createJob).\r\n     * El empleador deposita el monto bruto. No se asigna freelancer ni se cobra comisión aún.\r\n     */\r\n    function createVacancy(string memory _description, string[] memory _skills, string memory _imageURI) public payable {\r\n        require(msg.value > 0, \"El monto de la vacante debe ser mayor a cero.\");\r\n\r\n        jobs[nextJobId] = Job({\r\n            employer: msg.sender,\r\n            freelancer: address(0), // El freelancer se asignará después.\r\n            amount: msg.value,      // Se guarda el monto bruto depositado.\r\n            state: JobState.Open,    // El trabajo está abierto para postulaciones.\r\n            description: _description,\r\n            skills: _skills,\r\n            imageURI: _imageURI\r\n        });\r\n\r\n        emit VacancyCreated(nextJobId, msg.sender, msg.value, _description, _skills, _imageURI);\r\n        nextJobId++;\r\n    }\r\n\r\n    /**\r\n     * @dev PASO 3: Nueva función para que el empleador contrate a un freelancer para una vacante abierta.\r\n     * En este paso se cobra la comisión de la plataforma.\r\n     * @param jobId El ID de la vacante a la que se asignará el freelancer.\r\n     * @param freelancerAddress La dirección del freelancer que se va a contratar.\r\n     */\r\n    function hireFreelancer(uint256 jobId, address freelancerAddress) public {\r\n        Job storage job = jobs[jobId];\r\n\r\n        require(msg.sender == job.employer, \"Solo el empleador puede contratar.\");\r\n        require(job.state == JobState.Open, \"La vacante no esta abierta.\");\r\n        require(freelancerAddress != address(0), \"La direccion del freelancer es invalida.\");\r\n\r\n        // --- LÓGICA DE LA COMISIÓN (se ejecuta aquí) ---\r\n        uint256 grossAmount = job.amount;\r\n        uint256 commissionAmount = (grossAmount * commissionPercentage) / 100;\r\n        uint256 netAmount = grossAmount - commissionAmount;\r\n\r\n        // Se transfiere la comisión a la plataforma.\r\n        (bool success, ) = platformOwner.call{value: commissionAmount}(\"\");\r\n        require(success, \"Fallo al transferir la comision a la plataforma.\");\r\n\r\n        // Se actualiza el trabajo con los nuevos datos.\r\n        job.freelancer = freelancerAddress;\r\n        job.amount = netAmount; // El monto en escrow ahora es el neto para el freelancer.\r\n        job.state = JobState.InProgress;\r\n\r\n        emit FreelancerHired(jobId, freelancerAddress, netAmount, commissionAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Libera los fondos (netos) al freelancer. La lógica interna no cambia.\r\n     */\r\n    function releaseFunds(uint256 jobId) public {\r\n        Job storage job = jobs[jobId];\r\n        require(msg.sender == job.employer, \"Solo el empleador puede liberar los fondos.\");\r\n        require(job.state == JobState.InProgress, \"El trabajo no esta en progreso.\");\r\n\r\n        job.state = JobState.Completed;\r\n        (bool success, ) = job.freelancer.call{value: job.amount}(\"\");\r\n        require(success, \"Fallo al enviar el Ether al freelancer.\");\r\n\r\n        emit FundsReleased(jobId, job.freelancer, job.amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Inicia una disputa. Ahora se puede disputar también un trabajo en estado 'Open'.\r\n     */\r\n    function raiseDispute(uint256 jobId) public {\r\n        Job storage job = jobs[jobId];\r\n        require(msg.sender == job.employer || msg.sender == job.freelancer, \"Solo las partes involucradas pueden disputar.\");\r\n        // Se puede disputar mientras el trabajo esté en progreso. Si está 'Open', el empleador puede querer cancelar.\r\n        require(job.state == JobState.InProgress || job.state == JobState.Open, \"El trabajo no esta en un estado disputable.\");\r\n\r\n        job.state = JobState.Disputed;\r\n        emit DisputeRaised(jobId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Resuelve una disputa. La lógica opera sobre el monto en escrow en ese momento.\r\n     */\r\n    function resolveDispute(uint256 jobId, uint8 freelancerPercentage) public {\r\n        require(msg.sender == arbiter, \"Solo el arbitro puede resolver disputas.\");\r\n        require(freelancerPercentage <= 100, \"El porcentaje no puede ser mayor a 100.\");\r\n\r\n        Job storage job = jobs[jobId];\r\n        require(job.state == JobState.Disputed, \"El trabajo no esta en disputa.\");\r\n\r\n        job.state = JobState.Resolved;\r\n\r\n        uint256 totalAmountInEscrow = job.amount;\r\n        uint256 freelancerAmount = (totalAmountInEscrow * freelancerPercentage) / 100;\r\n        uint256 employerAmount = totalAmountInEscrow - freelancerAmount;\r\n\r\n        // Si el trabajo estaba en estado 'Open', no hay freelancer a quien pagar.\r\n        // El árbitro decide si el 100% vuelve al empleador.\r\n        if (freelancerAmount > 0 && job.freelancer != address(0)) {\r\n            (bool success, ) = job.freelancer.call{value: freelancerAmount}(\"\");\r\n            require(success, \"Fallo al enviar el Ether al freelancer.\");\r\n        }\r\n\r\n        if (employerAmount > 0) {\r\n            (bool success, ) = job.employer.call{value: employerAmount}(\"\");\r\n            require(success, \"Fallo al enviar el Ether al empleador.\");\r\n        }\r\n\r\n        emit DisputeResolved(jobId, freelancerAmount, employerAmount);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}